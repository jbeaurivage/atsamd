#![doc = r" Builder file for Peripheral access crate generated by svd2rust tool"]
use anyhow::anyhow;
use anyhow::Context;
use std::env;
use std::fs;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::path::PathBuf;
use std::process::Command;
use svd2rust::config::IdentFormats;

use libxml::{parser::Parser as XMLParser, tree::SaveOptions};
use libxslt::parser as xslt_parser;

macro_rules! p {
    ($($tokens: tt)*) => {
        println!("cargo::warning={}", format!($($tokens)*))
    }
}

fn find_file(chip_name: &str, dir: impl AsRef<Path>, extension: &str) -> Option<String> {
    // Get all entries in the svd directory
    let dir = dir.as_ref();

    // Check if the svd directory exists
    if !dir.exists() || !dir.is_dir() {
        println!("SVD directory not found");
        return None;
    }

    // Read all entries in the directory
    let entries = match fs::read_dir(dir) {
        Ok(entries) => entries,
        Err(e) => {
            println!("Error reading SVD directory: {}", e);
            return None;
        }
    };

    // Look for files that start with the chip name
    for entry in entries {
        if let Ok(entry) = entry {
            let path = entry.path();

            // Skip if not a file
            if !path.is_file() {
                continue;
            }

            // Get file stem and extension
            if let Some(file_name) = path.file_name() {
                let file_name_str = file_name
                    .to_os_string()
                    .into_string()
                    .expect("Could not get path")
                    .to_lowercase();
                let chip_name_lower = chip_name.to_lowercase();

                // Check if the file name starts with the chip name (case insensitive)
                if file_name_str.starts_with(&chip_name_lower) {
                    // Check for .svd or .svd.patched extension
                    if let Some(ext) = path.extension() {
                        let ext_str = ext.to_string_lossy();
                        if ext_str == extension {
                            let path = path
                                .into_os_string()
                                .into_string()
                                .expect("Could not get path");
                            return Some(path);
                        }
                    }
                }
            }
        }
    }

    None
}

fn extract_chip_name() -> Option<String> {
    let pkg_name = env!("CARGO_PKG_NAME");
    let re = regex::Regex::new(r"atsam[a-z]\d{2}[a-z]+").unwrap();

    Some(re.captures(&pkg_name)?.get(0)?.as_str().to_owned())
}

fn main() -> anyhow::Result<()> {
    const PAC_FILE_NAME: &str = "pac.rs";
    // Extract chip name, and find SVD + XSL
    let chip_name = extract_chip_name().context("Could not extract chip name")?;
    let xsl = find_file(&chip_name, "../../svd/devices", "xsl").context("Could not find xsl")?;
    let svd = find_file(&chip_name.to_ascii_uppercase(), "../../svd", "svd")
        .context("Could not find SVD")?;

    // Parse SVD
    let xml_parser = XMLParser::default();
    let source = xml_parser.parse_file(&svd).unwrap();

    // Apply XSLT
    let mut stylesheet = xslt_parser::parse_file(&xsl).unwrap();
    let transform_result = stylesheet.transform(&source, Vec::new()).unwrap();
    let patched_svd = transform_result.to_string_with_options(SaveOptions {
        format: true,
        ..SaveOptions::default()
    });

    // svd2rust config
    let config_path = Path::new("../svd2rust.toml");
    let config_content = fs::read_to_string(config_path).context(format!(
        "could not open svd2rust config file at {}",
        config_path.display()
    ))?;

    let mut config: svd2rust::config::Config = toml::from_str(&config_content)?;
    config.ident_formats = IdentFormats::default_theme();
    config.make_mod = false;

    // Generate PAC
    let generated = svd2rust::generate(&patched_svd, &config)?;

    let out = env::var("OUT_DIR").unwrap();
    form::create_directory_structure(format!("{out}/src"), &generated.lib_rs, true)?;

    // let out_file = format!("{out}/src/pac.rs");
    // fs::rename(format!("{out}/src/lib.rs"), &out_file)?;
    // fs::write(
    //     format!("{out}/src/lib.rs"),
    //     format!(r#"#[path="{out_file}"] mod pac;"#),
    // )?;

    // Write generated result to output directory as OUT_DIR/pac.rs
    //
    // let out_file = format!("{out}/pac.rs");
    // fs::write(&out_file, generated.lib_rs).unwrap();

    // let _ = Command::new("rustfmt").arg(out_file).status();

    // fs::write(
    //     format!("{out}/lib.rs"),
    //     format!(r#"#[path="{out}/pac.rs"] mod pac; pub use pac::*; pub use super::*;"#),
    // )
    // .unwrap();

    if env::var_os("CARGO_FEATURE_RT").is_some() {
        let out = &PathBuf::from(env::var_os("OUT_DIR").unwrap());
        File::create(out.join("device.x"))
            .unwrap()
            .write_all(include_bytes!("device.x"))
            .unwrap();
        println!("cargo:rustc-link-search={}", out.display());
        println!("cargo:rerun-if-changed=device.x");
    }
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=../svd2rust.toml");

    Ok(())
}
